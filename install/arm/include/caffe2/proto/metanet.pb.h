// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/metanet.proto

#ifndef PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED
#define PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "caffe2/proto/caffe2.pb.h"
// @@protoc_insertion_point(includes)

namespace caffe2 {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto();
void protobuf_InitDefaults_caffe2_2fproto_2fmetanet_2eproto();
void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

class BlobsMap;
class MetaNetDef;
class ModelInfo;
class NetsMap;
class PlansMap;
class StringMap;

// ===================================================================

class ModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.ModelInfo) */ {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo& default_instance();

  static const ModelInfo* internal_default_instance();

  void Swap(ModelInfo* other);

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const { return New(NULL); }

  ModelInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo* other);
  void UnsafeMergeFrom(const ModelInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string project = 1;
  bool has_project() const;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // optional string modelClass = 2;
  bool has_modelclass() const;
  void clear_modelclass();
  static const int kModelClassFieldNumber = 2;
  const ::std::string& modelclass() const;
  void set_modelclass(const ::std::string& value);
  void set_modelclass(const char* value);
  void set_modelclass(const char* value, size_t size);
  ::std::string* mutable_modelclass();
  ::std::string* release_modelclass();
  void set_allocated_modelclass(::std::string* modelclass);

  // optional string version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string predictorType = 4 [default = "SINGLE_PREDICTOR"];
  bool has_predictortype() const;
  void clear_predictortype();
  static const int kPredictorTypeFieldNumber = 4;
  const ::std::string& predictortype() const;
  void set_predictortype(const ::std::string& value);
  void set_predictortype(const char* value);
  void set_predictortype(const char* value, size_t size);
  ::std::string* mutable_predictortype();
  ::std::string* release_predictortype();
  void set_allocated_predictortype(::std::string* predictortype);

  // optional string modelId = 5;
  bool has_modelid() const;
  void clear_modelid();
  static const int kModelIdFieldNumber = 5;
  const ::std::string& modelid() const;
  void set_modelid(const ::std::string& value);
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  ::std::string* mutable_modelid();
  ::std::string* release_modelid();
  void set_allocated_modelid(::std::string* modelid);

  // @@protoc_insertion_point(class_scope:caffe2.ModelInfo)
 private:
  inline void set_has_project();
  inline void clear_has_project();
  inline void set_has_modelclass();
  inline void clear_has_modelclass();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_predictortype();
  inline void clear_has_predictortype();
  inline void set_has_modelid();
  inline void clear_has_modelid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr modelclass_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  static ::std::string* _default_predictortype_;
  ::google::protobuf::internal::ArenaStringPtr predictortype_;
  ::google::protobuf::internal::ArenaStringPtr modelid_;
  friend void  protobuf_InitDefaults_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void  protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ModelInfo> ModelInfo_default_instance_;

// -------------------------------------------------------------------

class BlobsMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.BlobsMap) */ {
 public:
  BlobsMap();
  virtual ~BlobsMap();

  BlobsMap(const BlobsMap& from);

  inline BlobsMap& operator=(const BlobsMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobsMap& default_instance();

  static const BlobsMap* internal_default_instance();

  void Swap(BlobsMap* other);

  // implements Message ----------------------------------------------

  inline BlobsMap* New() const { return New(NULL); }

  BlobsMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobsMap& from);
  void MergeFrom(const BlobsMap& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlobsMap* other);
  void UnsafeMergeFrom(const BlobsMap& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // repeated string value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:caffe2.BlobsMap)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend void  protobuf_InitDefaults_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void  protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BlobsMap> BlobsMap_default_instance_;

// -------------------------------------------------------------------

class NetsMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.NetsMap) */ {
 public:
  NetsMap();
  virtual ~NetsMap();

  NetsMap(const NetsMap& from);

  inline NetsMap& operator=(const NetsMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetsMap& default_instance();

  static const NetsMap* internal_default_instance();

  void Swap(NetsMap* other);

  // implements Message ----------------------------------------------

  inline NetsMap* New() const { return New(NULL); }

  NetsMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetsMap& from);
  void MergeFrom(const NetsMap& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetsMap* other);
  void UnsafeMergeFrom(const NetsMap& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .caffe2.NetDef value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::caffe2::NetDef& value() const;
  ::caffe2::NetDef* mutable_value();
  ::caffe2::NetDef* release_value();
  void set_allocated_value(::caffe2::NetDef* value);

  // @@protoc_insertion_point(class_scope:caffe2.NetsMap)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::caffe2::NetDef* value_;
  friend void  protobuf_InitDefaults_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void  protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<NetsMap> NetsMap_default_instance_;

// -------------------------------------------------------------------

class PlansMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.PlansMap) */ {
 public:
  PlansMap();
  virtual ~PlansMap();

  PlansMap(const PlansMap& from);

  inline PlansMap& operator=(const PlansMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlansMap& default_instance();

  static const PlansMap* internal_default_instance();

  void Swap(PlansMap* other);

  // implements Message ----------------------------------------------

  inline PlansMap* New() const { return New(NULL); }

  PlansMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlansMap& from);
  void MergeFrom(const PlansMap& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlansMap* other);
  void UnsafeMergeFrom(const PlansMap& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .caffe2.PlanDef value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::caffe2::PlanDef& value() const;
  ::caffe2::PlanDef* mutable_value();
  ::caffe2::PlanDef* release_value();
  void set_allocated_value(::caffe2::PlanDef* value);

  // @@protoc_insertion_point(class_scope:caffe2.PlansMap)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::caffe2::PlanDef* value_;
  friend void  protobuf_InitDefaults_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void  protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PlansMap> PlansMap_default_instance_;

// -------------------------------------------------------------------

class StringMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.StringMap) */ {
 public:
  StringMap();
  virtual ~StringMap();

  StringMap(const StringMap& from);

  inline StringMap& operator=(const StringMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringMap& default_instance();

  static const StringMap* internal_default_instance();

  void Swap(StringMap* other);

  // implements Message ----------------------------------------------

  inline StringMap* New() const { return New(NULL); }

  StringMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringMap& from);
  void MergeFrom(const StringMap& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringMap* other);
  void UnsafeMergeFrom(const StringMap& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:caffe2.StringMap)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_InitDefaults_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void  protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<StringMap> StringMap_default_instance_;

// -------------------------------------------------------------------

class MetaNetDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.MetaNetDef) */ {
 public:
  MetaNetDef();
  virtual ~MetaNetDef();

  MetaNetDef(const MetaNetDef& from);

  inline MetaNetDef& operator=(const MetaNetDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaNetDef& default_instance();

  static const MetaNetDef* internal_default_instance();

  void Swap(MetaNetDef* other);

  // implements Message ----------------------------------------------

  inline MetaNetDef* New() const { return New(NULL); }

  MetaNetDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaNetDef& from);
  void MergeFrom(const MetaNetDef& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaNetDef* other);
  void UnsafeMergeFrom(const MetaNetDef& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.BlobsMap blobs = 1;
  int blobs_size() const;
  void clear_blobs();
  static const int kBlobsFieldNumber = 1;
  const ::caffe2::BlobsMap& blobs(int index) const;
  ::caffe2::BlobsMap* mutable_blobs(int index);
  ::caffe2::BlobsMap* add_blobs();
  ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >*
      mutable_blobs();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >&
      blobs() const;

  // repeated .caffe2.NetsMap nets = 2;
  int nets_size() const;
  void clear_nets();
  static const int kNetsFieldNumber = 2;
  const ::caffe2::NetsMap& nets(int index) const;
  ::caffe2::NetsMap* mutable_nets(int index);
  ::caffe2::NetsMap* add_nets();
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >*
      mutable_nets();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >&
      nets() const;

  // optional .caffe2.ModelInfo modelInfo = 3;
  bool has_modelinfo() const;
  void clear_modelinfo();
  static const int kModelInfoFieldNumber = 3;
  const ::caffe2::ModelInfo& modelinfo() const;
  ::caffe2::ModelInfo* mutable_modelinfo();
  ::caffe2::ModelInfo* release_modelinfo();
  void set_allocated_modelinfo(::caffe2::ModelInfo* modelinfo);

  // repeated .caffe2.PlansMap plans = 4;
  int plans_size() const;
  void clear_plans();
  static const int kPlansFieldNumber = 4;
  const ::caffe2::PlansMap& plans(int index) const;
  ::caffe2::PlansMap* mutable_plans(int index);
  ::caffe2::PlansMap* add_plans();
  ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >*
      mutable_plans();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >&
      plans() const;

  // repeated .caffe2.StringMap applicationSpecificInfo = 5;
  int applicationspecificinfo_size() const;
  void clear_applicationspecificinfo();
  static const int kApplicationSpecificInfoFieldNumber = 5;
  const ::caffe2::StringMap& applicationspecificinfo(int index) const;
  ::caffe2::StringMap* mutable_applicationspecificinfo(int index);
  ::caffe2::StringMap* add_applicationspecificinfo();
  ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >*
      mutable_applicationspecificinfo();
  const ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >&
      applicationspecificinfo() const;

  // @@protoc_insertion_point(class_scope:caffe2.MetaNetDef)
 private:
  inline void set_has_modelinfo();
  inline void clear_has_modelinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap > blobs_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap > nets_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap > plans_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap > applicationspecificinfo_;
  ::caffe2::ModelInfo* modelinfo_;
  friend void  protobuf_InitDefaults_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void  protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto_impl();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MetaNetDef> MetaNetDef_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ModelInfo

// optional string project = 1;
inline bool ModelInfo::has_project() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelInfo::set_has_project() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelInfo::clear_has_project() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelInfo::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_project();
}
inline const ::std::string& ModelInfo::project() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.project)
  return project_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_project(const ::std::string& value) {
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value) {
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value, size_t size) {
  set_has_project();
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.project)
}
inline ::std::string* ModelInfo::mutable_project() {
  set_has_project();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_project() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.project)
  clear_has_project();
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_project(::std::string* project) {
  if (project != NULL) {
    set_has_project();
  } else {
    clear_has_project();
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.project)
}

// optional string modelClass = 2;
inline bool ModelInfo::has_modelclass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelInfo::set_has_modelclass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelInfo::clear_has_modelclass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelInfo::clear_modelclass() {
  modelclass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelclass();
}
inline const ::std::string& ModelInfo::modelclass() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.modelClass)
  return modelclass_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_modelclass(const ::std::string& value) {
  set_has_modelclass();
  modelclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.modelClass)
}
inline void ModelInfo::set_modelclass(const char* value) {
  set_has_modelclass();
  modelclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.modelClass)
}
inline void ModelInfo::set_modelclass(const char* value, size_t size) {
  set_has_modelclass();
  modelclass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.modelClass)
}
inline ::std::string* ModelInfo::mutable_modelclass() {
  set_has_modelclass();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.modelClass)
  return modelclass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_modelclass() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.modelClass)
  clear_has_modelclass();
  return modelclass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_modelclass(::std::string* modelclass) {
  if (modelclass != NULL) {
    set_has_modelclass();
  } else {
    clear_has_modelclass();
  }
  modelclass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelclass);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.modelClass)
}

// optional string version = 3;
inline bool ModelInfo::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelInfo::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& ModelInfo::version() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.version)
}
inline ::std::string* ModelInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_version() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.version)
}

// optional string predictorType = 4 [default = "SINGLE_PREDICTOR"];
inline bool ModelInfo::has_predictortype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelInfo::set_has_predictortype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelInfo::clear_has_predictortype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelInfo::clear_predictortype() {
  predictortype_.ClearToDefaultNoArena(_default_predictortype_);
  clear_has_predictortype();
}
inline const ::std::string& ModelInfo::predictortype() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.predictorType)
  return predictortype_.GetNoArena(_default_predictortype_);
}
inline void ModelInfo::set_predictortype(const ::std::string& value) {
  set_has_predictortype();
  predictortype_.SetNoArena(_default_predictortype_, value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.predictorType)
}
inline void ModelInfo::set_predictortype(const char* value) {
  set_has_predictortype();
  predictortype_.SetNoArena(_default_predictortype_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.predictorType)
}
inline void ModelInfo::set_predictortype(const char* value, size_t size) {
  set_has_predictortype();
  predictortype_.SetNoArena(_default_predictortype_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.predictorType)
}
inline ::std::string* ModelInfo::mutable_predictortype() {
  set_has_predictortype();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.predictorType)
  return predictortype_.MutableNoArena(_default_predictortype_);
}
inline ::std::string* ModelInfo::release_predictortype() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.predictorType)
  clear_has_predictortype();
  return predictortype_.ReleaseNoArena(_default_predictortype_);
}
inline void ModelInfo::set_allocated_predictortype(::std::string* predictortype) {
  if (predictortype != NULL) {
    set_has_predictortype();
  } else {
    clear_has_predictortype();
  }
  predictortype_.SetAllocatedNoArena(_default_predictortype_, predictortype);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.predictorType)
}

// optional string modelId = 5;
inline bool ModelInfo::has_modelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelInfo::set_has_modelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelInfo::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelInfo::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modelid();
}
inline const ::std::string& ModelInfo::modelid() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.modelId)
  return modelid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_modelid(const ::std::string& value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.modelId)
}
inline void ModelInfo::set_modelid(const char* value) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.modelId)
}
inline void ModelInfo::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  modelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.modelId)
}
inline ::std::string* ModelInfo::mutable_modelid() {
  set_has_modelid();
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.modelId)
  return modelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo::release_modelid() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.modelId)
  clear_has_modelid();
  return modelid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_modelid(::std::string* modelid) {
  if (modelid != NULL) {
    set_has_modelid();
  } else {
    clear_has_modelid();
  }
  modelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.modelId)
}

inline const ModelInfo* ModelInfo::internal_default_instance() {
  return &ModelInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// BlobsMap

// required string key = 1;
inline bool BlobsMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobsMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobsMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobsMap::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& BlobsMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobsMap.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlobsMap::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.key)
}
inline void BlobsMap::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobsMap.key)
}
inline void BlobsMap::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobsMap.key)
}
inline ::std::string* BlobsMap::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.BlobsMap.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlobsMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.BlobsMap.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlobsMap::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobsMap.key)
}

// repeated string value = 2;
inline int BlobsMap::value_size() const {
  return value_.size();
}
inline void BlobsMap::clear_value() {
  value_.Clear();
}
inline const ::std::string& BlobsMap::value(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.BlobsMap.value)
  return value_.Get(index);
}
inline ::std::string* BlobsMap::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobsMap.value)
  return value_.Mutable(index);
}
inline void BlobsMap::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.value)
  value_.Mutable(index)->assign(value);
}
inline void BlobsMap::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.BlobsMap.value)
}
inline void BlobsMap::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobsMap.value)
}
inline ::std::string* BlobsMap::add_value() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.BlobsMap.value)
  return value_.Add();
}
inline void BlobsMap::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.BlobsMap.value)
}
inline void BlobsMap::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.BlobsMap.value)
}
inline void BlobsMap::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.BlobsMap.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BlobsMap::value() const {
  // @@protoc_insertion_point(field_list:caffe2.BlobsMap.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BlobsMap::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.BlobsMap.value)
  return &value_;
}

inline const BlobsMap* BlobsMap::internal_default_instance() {
  return &BlobsMap_default_instance_.get();
}
// -------------------------------------------------------------------

// NetsMap

// required string key = 1;
inline bool NetsMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetsMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetsMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetsMap::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& NetsMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.NetsMap.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetsMap::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.NetsMap.key)
}
inline void NetsMap::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.NetsMap.key)
}
inline void NetsMap::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetsMap.key)
}
inline ::std::string* NetsMap::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.NetsMap.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetsMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.NetsMap.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetsMap::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetsMap.key)
}

// required .caffe2.NetDef value = 2;
inline bool NetsMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetsMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetsMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetsMap::clear_value() {
  if (value_ != NULL) value_->::caffe2::NetDef::Clear();
  clear_has_value();
}
inline const ::caffe2::NetDef& NetsMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.NetsMap.value)
  return value_ != NULL ? *value_
                         : *::caffe2::NetDef::internal_default_instance();
}
inline ::caffe2::NetDef* NetsMap::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::caffe2::NetDef;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.NetsMap.value)
  return value_;
}
inline ::caffe2::NetDef* NetsMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.NetsMap.value)
  clear_has_value();
  ::caffe2::NetDef* temp = value_;
  value_ = NULL;
  return temp;
}
inline void NetsMap::set_allocated_value(::caffe2::NetDef* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetsMap.value)
}

inline const NetsMap* NetsMap::internal_default_instance() {
  return &NetsMap_default_instance_.get();
}
// -------------------------------------------------------------------

// PlansMap

// required string key = 1;
inline bool PlansMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlansMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlansMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlansMap::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& PlansMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.PlansMap.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlansMap::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.PlansMap.key)
}
inline void PlansMap::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.PlansMap.key)
}
inline void PlansMap::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.PlansMap.key)
}
inline ::std::string* PlansMap::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.PlansMap.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlansMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.PlansMap.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlansMap::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlansMap.key)
}

// required .caffe2.PlanDef value = 2;
inline bool PlansMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlansMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlansMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlansMap::clear_value() {
  if (value_ != NULL) value_->::caffe2::PlanDef::Clear();
  clear_has_value();
}
inline const ::caffe2::PlanDef& PlansMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.PlansMap.value)
  return value_ != NULL ? *value_
                         : *::caffe2::PlanDef::internal_default_instance();
}
inline ::caffe2::PlanDef* PlansMap::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::caffe2::PlanDef;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.PlansMap.value)
  return value_;
}
inline ::caffe2::PlanDef* PlansMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.PlansMap.value)
  clear_has_value();
  ::caffe2::PlanDef* temp = value_;
  value_ = NULL;
  return temp;
}
inline void PlansMap::set_allocated_value(::caffe2::PlanDef* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlansMap.value)
}

inline const PlansMap* PlansMap::internal_default_instance() {
  return &PlansMap_default_instance_.get();
}
// -------------------------------------------------------------------

// StringMap

// required string key = 1;
inline bool StringMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringMap::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& StringMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.StringMap.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringMap::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.StringMap.key)
}
inline void StringMap::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.StringMap.key)
}
inline void StringMap::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.StringMap.key)
}
inline ::std::string* StringMap::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:caffe2.StringMap.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.StringMap.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringMap::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.StringMap.key)
}

// required string value = 2;
inline bool StringMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringMap::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& StringMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.StringMap.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringMap::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:caffe2.StringMap.value)
}
inline void StringMap::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.StringMap.value)
}
inline void StringMap::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.StringMap.value)
}
inline ::std::string* StringMap::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:caffe2.StringMap.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.StringMap.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringMap::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:caffe2.StringMap.value)
}

inline const StringMap* StringMap::internal_default_instance() {
  return &StringMap_default_instance_.get();
}
// -------------------------------------------------------------------

// MetaNetDef

// repeated .caffe2.BlobsMap blobs = 1;
inline int MetaNetDef::blobs_size() const {
  return blobs_.size();
}
inline void MetaNetDef::clear_blobs() {
  blobs_.Clear();
}
inline const ::caffe2::BlobsMap& MetaNetDef::blobs(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.blobs)
  return blobs_.Get(index);
}
inline ::caffe2::BlobsMap* MetaNetDef::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.blobs)
  return blobs_.Mutable(index);
}
inline ::caffe2::BlobsMap* MetaNetDef::add_blobs() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.blobs)
  return blobs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >*
MetaNetDef::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.blobs)
  return &blobs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >&
MetaNetDef::blobs() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.blobs)
  return blobs_;
}

// repeated .caffe2.NetsMap nets = 2;
inline int MetaNetDef::nets_size() const {
  return nets_.size();
}
inline void MetaNetDef::clear_nets() {
  nets_.Clear();
}
inline const ::caffe2::NetsMap& MetaNetDef::nets(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.nets)
  return nets_.Get(index);
}
inline ::caffe2::NetsMap* MetaNetDef::mutable_nets(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.nets)
  return nets_.Mutable(index);
}
inline ::caffe2::NetsMap* MetaNetDef::add_nets() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.nets)
  return nets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >*
MetaNetDef::mutable_nets() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.nets)
  return &nets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >&
MetaNetDef::nets() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.nets)
  return nets_;
}

// optional .caffe2.ModelInfo modelInfo = 3;
inline bool MetaNetDef::has_modelinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaNetDef::set_has_modelinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaNetDef::clear_has_modelinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaNetDef::clear_modelinfo() {
  if (modelinfo_ != NULL) modelinfo_->::caffe2::ModelInfo::Clear();
  clear_has_modelinfo();
}
inline const ::caffe2::ModelInfo& MetaNetDef::modelinfo() const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.modelInfo)
  return modelinfo_ != NULL ? *modelinfo_
                         : *::caffe2::ModelInfo::internal_default_instance();
}
inline ::caffe2::ModelInfo* MetaNetDef::mutable_modelinfo() {
  set_has_modelinfo();
  if (modelinfo_ == NULL) {
    modelinfo_ = new ::caffe2::ModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.modelInfo)
  return modelinfo_;
}
inline ::caffe2::ModelInfo* MetaNetDef::release_modelinfo() {
  // @@protoc_insertion_point(field_release:caffe2.MetaNetDef.modelInfo)
  clear_has_modelinfo();
  ::caffe2::ModelInfo* temp = modelinfo_;
  modelinfo_ = NULL;
  return temp;
}
inline void MetaNetDef::set_allocated_modelinfo(::caffe2::ModelInfo* modelinfo) {
  delete modelinfo_;
  modelinfo_ = modelinfo;
  if (modelinfo) {
    set_has_modelinfo();
  } else {
    clear_has_modelinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.MetaNetDef.modelInfo)
}

// repeated .caffe2.PlansMap plans = 4;
inline int MetaNetDef::plans_size() const {
  return plans_.size();
}
inline void MetaNetDef::clear_plans() {
  plans_.Clear();
}
inline const ::caffe2::PlansMap& MetaNetDef::plans(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.plans)
  return plans_.Get(index);
}
inline ::caffe2::PlansMap* MetaNetDef::mutable_plans(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.plans)
  return plans_.Mutable(index);
}
inline ::caffe2::PlansMap* MetaNetDef::add_plans() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.plans)
  return plans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >*
MetaNetDef::mutable_plans() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.plans)
  return &plans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >&
MetaNetDef::plans() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.plans)
  return plans_;
}

// repeated .caffe2.StringMap applicationSpecificInfo = 5;
inline int MetaNetDef::applicationspecificinfo_size() const {
  return applicationspecificinfo_.size();
}
inline void MetaNetDef::clear_applicationspecificinfo() {
  applicationspecificinfo_.Clear();
}
inline const ::caffe2::StringMap& MetaNetDef::applicationspecificinfo(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Get(index);
}
inline ::caffe2::StringMap* MetaNetDef::mutable_applicationspecificinfo(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Mutable(index);
}
inline ::caffe2::StringMap* MetaNetDef::add_applicationspecificinfo() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >*
MetaNetDef::mutable_applicationspecificinfo() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.applicationSpecificInfo)
  return &applicationspecificinfo_;
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >&
MetaNetDef::applicationspecificinfo() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_;
}

inline const MetaNetDef* MetaNetDef::internal_default_instance() {
  return &MetaNetDef_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe2

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED
